/**
 * Reschedule Appointment - Enhanced System
 * 
 * Features:
 * - Load current appointment details
 * - Display appointment information
 * - Calendar integration for new appointment selection
 * - Form submission for rescheduling
 * - Validation and error handling
 */

console.log('🔄 Reschedule.js loaded');

// ───────── GLOBAL VARIABLES ─────────
let currentAppointment = null;
let appointmentId = null;
let calendarEl, timeCardsEl, bookingForm, selectedDateInput, selectedTimeInput;
let weekOffset = 0;
let currentDateISO = null;

// Business hours will be loaded from API
let BUSINESS_HOURS = [];

// Authentication - use AuthManager if available
const token = window.authManager && window.authManager.isLoggedIn() 
    ? window.authManager.getToken() 
    : (localStorage.getItem('user_token') || localStorage.getItem('token'));

// ───────── INITIALIZATION ─────────
document.addEventListener('DOMContentLoaded', async function() {
    console.log('🔄 DOMContentLoaded event fired');
    console.log('🔄 AuthManager available:', !!window.authManager);
    console.log('🔄 Token from localStorage:', !!(localStorage.getItem('user_token') || localStorage.getItem('token')));
    
    // Give AuthManager a moment to initialize
    if (window.authManager) {
        await new Promise(resolve => setTimeout(resolve, 100));
        console.log('🔄 AuthManager ready');
    }
    
    // Initialize DOM references
    initializeDOMReferences();
    
    // Get appointment ID from URL
    const urlParams = new URLSearchParams(window.location.search);
    appointmentId = urlParams.get('id');
    
    if (!appointmentId) {
        showMessage('ID de cita no encontrado', 'error');
        setTimeout(() => {
            window.location.href = 'mis-citas.html';
        }, 2000);
        return;
    }

    // Check authentication - but continue even if not authenticated for testing
    const isAuthenticated = window.authManager 
        ? window.authManager.isLoggedIn() 
        : (localStorage.getItem('user_token') || localStorage.getItem('token'));
        
    if (!isAuthenticated) {
        console.warn('No authentication found, continuing for testing...');
        // For now, continue without authentication to test the basic functionality
        // showMessage('Debe iniciar sesión para reagendar citas', 'error');
        // setTimeout(() => {
        //     window.location.href = 'login.html';
        // }, 2000);
        // return;
    }

    // Initialize the reschedule system
    await initializeRescheduleSystem();
});

// ───────── DOM INITIALIZATION ─────────
function initializeDOMReferences() {
    calendarEl = document.getElementById('calendar');
    timeCardsEl = document.getElementById('timeCards');
    bookingForm = document.getElementById('bookingForm');
    selectedDateInput = document.getElementById('selectedDate');
    selectedTimeInput = document.getElementById('selectedTime');
}

// ───────── MAIN INITIALIZATION ─────────
async function initializeRescheduleSystem() {
    try {
        // Load business hours
        await fetchBusinessHours();
        
        // Load current appointment details
        await loadCurrentAppointment();
        
        // Initialize calendar
        renderWeek();
        
        // Setup form submission
        setupFormSubmission();
        
        console.log('✅ Reschedule system initialized successfully');
    } catch (error) {
        console.error('❌ Error initializing reschedule system:', error);
        showMessage('Error al cargar el sistema de reagendamiento', 'error');
    }
}

// ───────── APPOINTMENT LOADING ─────────
async function loadCurrentAppointment() {
    console.log('🔄 Loading appointment with ID:', appointmentId);
    try {
        const authToken = window.authManager && window.authManager.isLoggedIn() 
            ? window.authManager.getToken() 
            : (localStorage.getItem('user_token') || localStorage.getItem('token'));
        
        console.log('🔄 Auth token available:', !!authToken);
        
        const headers = {
            'Content-Type': 'application/json'
        };
        
        // Only add authorization header if we have a token
        if (authToken) {
            headers['Authorization'] = `Bearer ${authToken}`;
        }
        
        console.log('🔄 Making request to:', `/api/appointments-test/${appointmentId}`);
            
        const response = await fetch(`/api/appointments-test/${appointmentId}`, {
            headers: headers
        });

        console.log('🔄 Response status:', response.status);

        if (!response.ok) {
            throw new Error('Error loading appointment');
        }

        currentAppointment = await response.json();
        displayCurrentAppointmentInfo();
        
    } catch (error) {
        console.error('Error loading current appointment:', error);
        showMessage('Error al cargar la información de la cita', 'error');
        setTimeout(() => {
            window.location.href = 'mis-citas.html';
        }, 2000);
    }
}

// ───────── DISPLAY CURRENT APPOINTMENT ─────────
function displayCurrentAppointmentInfo() {
    const appointmentInfoEl = document.getElementById('currentAppointmentInfo');
    
    if (!currentAppointment || !appointmentInfoEl) return;

    const formattedDate = formatDate(currentAppointment.date);
    const formattedTime = formatTime(currentAppointment.time);
    
    appointmentInfoEl.innerHTML = `
        <strong>Cita actual:</strong> ${formattedDate} a las ${formattedTime}<br>
        <strong>Estado:</strong> <span class="badge bg-${getStatusColor(currentAppointment.status)}">${getStatusText(currentAppointment.status)}</span>
        ${currentAppointment.note ? `<br><strong>Nota:</strong> ${currentAppointment.note}` : ''}
    `;
}

// ───────── BUSINESS HOURS ─────────
async function fetchBusinessHours() {
    try {
        const response = await fetch('/api/business-hours');
        if (!response.ok) {
            console.error('Error fetching business hours, using defaults');
            BUSINESS_HOURS = getDefaultBusinessHours();
            return;
        }
        
        const data = await response.json();
        BUSINESS_HOURS = data.business_hours || getDefaultBusinessHours();
        
        console.log('📅 Business hours loaded:', BUSINESS_HOURS);
    } catch (error) {
        console.error('Error fetching business hours:', error);
        BUSINESS_HOURS = getDefaultBusinessHours();
    }
}

function getDefaultBusinessHours() {
    return [
        { day_of_week: 'Monday', is_open: true, open_time: '09:00', close_time: '18:00' },
        { day_of_week: 'Tuesday', is_open: true, open_time: '09:00', close_time: '18:00' },
        { day_of_week: 'Wednesday', is_open: true, open_time: '09:00', close_time: '18:00' },
        { day_of_week: 'Thursday', is_open: true, open_time: '09:00', close_time: '18:00' },
        { day_of_week: 'Friday', is_open: true, open_time: '09:00', close_time: '18:00' },
        { day_of_week: 'Saturday', is_open: false, open_time: null, close_time: null },
        { day_of_week: 'Sunday', is_open: false, open_time: null, close_time: null }
    ];
}

// ───────── CALENDAR RENDERING ─────────
function renderWeek() {
    if (!calendarEl) return;
    
    const startDate = startOfWeek(weekOffset);
    const days = [];
    
    for (let i = 0; i < 7; i++) {
        const day = new Date(startDate);
        day.setDate(startDate.getDate() + i);
        days.push(day);
    }
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    calendarEl.innerHTML = `
        <div class="calendar-header d-flex justify-content-between align-items-center mb-3">
            <button class="btn btn-outline-primary" onclick="changeWeek(-1)">
                <i class="fas fa-chevron-left"></i> Anterior
            </button>
            <h4 class="mb-0">${formatWeekRange(days[0], days[6])}</h4>
            <button class="btn btn-outline-primary" onclick="changeWeek(1)">
                Siguiente <i class="fas fa-chevron-right"></i>
            </button>
        </div>
        <div class="row g-2">
            ${days.map(day => {
                const dayISO = iso(day);
                const isPast = day < today;
                const isToday = day.getTime() === today.getTime();
                const dayOfWeek = getDayOfWeekString(day);
                const businessDay = BUSINESS_HOURS.find(bh => bh.day_of_week === dayOfWeek);
                const isOpen = businessDay && businessDay.is_open;
                
                return `
                    <div class="col">
                        <div class="day-card ${isPast ? 'past' : ''} ${!isOpen ? 'closed' : ''}">
                            <div class="day-header ${isToday ? 'today' : ''}">
                                <div class="day-name">${day.toLocaleDateString('es-ES', { weekday: 'short' })}</div>
                                <div class="day-number">${day.getDate()}</div>
                            </div>
                            <div class="day-content">
                                ${isPast ? 
                                    '<small class="text-muted">Pasado</small>' : 
                                    !isOpen ? 
                                        '<small class="text-muted">Cerrado</small>' :
                                        `<button class="btn btn-sm btn-outline-primary w-100" onclick="selectDate('${dayISO}')">
                                            Seleccionar
                                        </button>`
                                }
                            </div>
                        </div>
                    </div>
                `;
            }).join('')}
        </div>
    `;
}

// ───────── DATE SELECTION ─────────
async function selectDate(dayISO) {
    currentDateISO = dayISO;
    selectedDateInput.value = dayISO;
    
    // Highlight selected date
    document.querySelectorAll('.day-card').forEach(card => {
        card.classList.remove('selected');
    });
    
    event.target.closest('.day-card').classList.add('selected');
    
    // Load available time slots
    await loadTimeSlots(dayISO);
}

async function loadTimeSlots(dayISO) {
    try {
        timeCardsEl.innerHTML = '<p class="text-muted"><i class="fas fa-spinner fa-spin me-2"></i>Cargando horarios...</p>';
        
        const availableSlots = await fetchAvailableSlots(dayISO);
        
        if (availableSlots.length === 0) {
            timeCardsEl.innerHTML = '<p class="text-muted">No hay horarios disponibles para esta fecha</p>';
            return;
        }
        
        timeCardsEl.innerHTML = availableSlots.map(timeSlot => `
            <div class="col-6 col-md-4 col-lg-3">
                <button class="btn btn-outline-success w-100 time-slot" 
                        data-time="${timeSlot}" 
                        onclick="selectTime('${timeSlot}')">
                    ${formatTime(timeSlot)}
                </button>
            </div>
        `).join('');
        
    } catch (error) {
        console.error('Error loading time slots:', error);
        timeCardsEl.innerHTML = '<p class="text-danger">Error al cargar horarios</p>';
    }
}

// ───────── TIME SELECTION ─────────
function selectTime(timeSlot) {
    selectedTimeInput.value = timeSlot;
    
    // Highlight selected time
    document.querySelectorAll('.time-slot').forEach(btn => {
        btn.classList.remove('btn-success');
        btn.classList.add('btn-outline-success');
    });
    
    event.target.classList.remove('btn-outline-success');
    event.target.classList.add('btn-success');
    
    // Show submit button
    const submitBtn = bookingForm.querySelector('button[type="submit"]');
    if (submitBtn) {
        submitBtn.style.display = 'block';
    }
}

// ───────── AVAILABLE SLOTS ─────────
async function fetchAvailableSlots(dayISO) {
    try {
        const response = await fetch(`/api/available-slots/${dayISO}`);
        if (!response.ok) {
            console.error('Error fetching available slots, falling back to basic method');
            return await fetchBasicAvailability(dayISO);
        }
        
        const data = await response.json();
        return data.availableSlots || [];
    } catch (error) {
        console.error('Error fetching available slots:', error);
        return await fetchBasicAvailability(dayISO);
    }
}

async function fetchBasicAvailability(dayISO) {
    const selectedDate = new Date(dayISO);
    const dayOfWeek = getDayOfWeekString(selectedDate);
    
    const businessDay = BUSINESS_HOURS.find(bh => bh.day_of_week === dayOfWeek);
    
    if (!businessDay || !businessDay.is_open) {
        return [];
    }

    const allSlots = generateTimeSlots(businessDay.open_time, businessDay.close_time);
    
    const taken = await fetchAppointments(dayISO);
    let available = allSlots.filter(t => !taken.includes(t));
    
    // Filter out slots that are less than 30 minutes from now (only for today)
    const now = new Date();
    const today = now.toISOString().split('T')[0];
    const thirtyMinutesFromNow = new Date(now.getTime() + (30 * 60 * 1000));
    
    if (dayISO === today) {
        available = available.filter(timeSlot => {
            const slotDateTime = new Date(`${dayISO}T${timeSlot}:00`);
            return slotDateTime >= thirtyMinutesFromNow;
        });
    }
    
    return available;
}

async function fetchAppointments(dayISO) {
    try {
        const response = await fetch(`/api/appointments/date/${dayISO}`);
        if (!response.ok) return [];
        
        const appointments = await response.json();
        return appointments.map(apt => apt.time);
    } catch (error) {
        console.error('Error fetching appointments:', error);
        return [];
    }
}

// ───────── FORM SUBMISSION ─────────
function setupFormSubmission() {
    if (!bookingForm) return;
    
    bookingForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const formData = new FormData(e.target);
        const data = {
            date: formData.get('date'),
            time: formData.get('time'),
            note: formData.get('note') || null
        };

        // Validate required fields
        if (!data.date || !data.time) {
            showMessage('Por favor selecciona una fecha y hora', 'error');
            return;
        }

        // Validate appointment time is at least 30 minutes in advance
        const appointmentDateTime = new Date(`${data.date}T${data.time}:00`);
        const now = new Date();
        const thirtyMinutesFromNow = new Date(now.getTime() + (30 * 60 * 1000));

        if (appointmentDateTime < thirtyMinutesFromNow) {
            showMessage('Las citas deben agendarse con al menos 30 minutos de anticipación', 'error');
            return;
        }

        try {
            // Show loading state
            const submitButton = e.target.querySelector('button[type="submit"]');
            const originalText = submitButton.innerHTML;
            submitButton.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Reagendando...';
            submitButton.disabled = true;

            const authToken = window.authManager && window.authManager.isLoggedIn() 
                ? window.authManager.getToken() 
                : localStorage.getItem('token');

            const response = await fetch(`/api/appointments/${appointmentId}/reschedule`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${authToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Error de conexión' }));
                throw new Error(errorData.error || 'Error al reagendar la cita');
            }

            const result = await response.json();
            
            // Show success message
            showMessage(result.message || 'Cita reagendada exitosamente', 'success');
            
            // Redirect to appointments page after a delay
            setTimeout(() => {
                window.location.href = 'mis-citas.html';
            }, 2000);
            
        } catch (error) {
            console.error('Error rescheduling appointment:', error);
            showMessage(error.message || 'Error al reagendar la cita', 'error');
            
            // Restore button
            const submitButton = e.target.querySelector('button[type="submit"]');
            submitButton.innerHTML = originalText;
            submitButton.disabled = false;
        }
    });
}

// ───────── UTILITY FUNCTIONS ─────────
function changeWeek(direction) {
    weekOffset += direction;
    renderWeek();
    
    // Clear time selection
    timeCardsEl.innerHTML = '<p class="text-muted">Selecciona una fecha para ver horarios disponibles</p>';
    selectedDateInput.value = '';
    selectedTimeInput.value = '';
    currentDateISO = null;
}

function generateTimeSlots(openTime, closeTime) {
    const slots = [];
    const [openHour, openMinute] = openTime.split(':').map(Number);
    const [closeHour, closeMinute] = closeTime.split(':').map(Number);
    
    let currentHour = openHour;
    let currentMinute = openMinute;
    
    while (currentHour < closeHour || (currentHour === closeHour && currentMinute < closeMinute)) {
        const timeSlot = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
        slots.push(timeSlot);
        
        currentMinute += 30;
        if (currentMinute >= 60) {
            currentMinute = 0;
            currentHour++;
        }
    }
    
    return slots;
}

function getDayOfWeekString(date) {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return days[date.getDay()];
}

function startOfWeek(offset = 0) {
    const d = new Date();
    d.setHours(0, 0, 0, 0);
    const dayOfWeek = d.getDay();
    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    d.setDate(d.getDate() + mondayOffset + (offset * 7));
    return d;
}

function iso(d) {
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

function formatDate(dateString) {
    const date = new Date(dateString + 'T00:00:00');
    return date.toLocaleDateString('es-ES', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });
}

function formatTime(timeString) {
    const [hour, minute] = timeString.split(':');
    const date = new Date();
    date.setHours(parseInt(hour), parseInt(minute));
    return date.toLocaleTimeString('es-ES', {
        hour: '2-digit',
        minute: '2-digit',
        hour12: true
    });
}

function formatWeekRange(startDate, endDate) {
    const options = { month: 'short', day: 'numeric' };
    return `${startDate.toLocaleDateString('es-ES', options)} - ${endDate.toLocaleDateString('es-ES', options)}`;
}

function getStatusColor(status) {
    switch (status) {
        case 'confirmed': return 'success';
        case 'pending': return 'warning';
        case 'cancelled': return 'danger';
        default: return 'secondary';
    }
}

function getStatusText(status) {
    switch (status) {
        case 'confirmed': return 'Confirmada';
        case 'pending': return 'Pendiente';
        case 'cancelled': return 'Cancelada';
        default: return 'Desconocido';
    }
}

function showMessage(message, type = 'info') {
    // Remove any existing messages
    const existingMessage = document.querySelector('.reschedule-message');
    if (existingMessage) {
        existingMessage.remove();
    }
    
    // Create new message
    const messageEl = document.createElement('div');
    messageEl.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show reschedule-message`;
    messageEl.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    // Insert at the top of the container
    const container = document.querySelector('.container');
    if (container) {
        container.insertBefore(messageEl, container.firstChild);
    }
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (messageEl && messageEl.parentNode) {
            messageEl.remove();
        }
    }, 5000);
}
